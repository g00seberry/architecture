import { IStrategyWithBind } from "../ex5/IStrategyWithBind";
import { tsCompile } from "./utils/compileTs";
import { FunctionInfo, InterfaceInfo } from "./utils/parseInterfaceFile";
import { AutoGeneratedClassDef } from "./types";

export class StrategyCraftAutoGeneratedClassStr
  implements IStrategyWithBind<AutoGeneratedClassDef>
{
  extractedData: InterfaceInfo | null = null;

  bind(extractedData: InterfaceInfo): IStrategyWithBind<AutoGeneratedClassDef> {
    this.extractedData = extractedData;
    return this;
  }

  execute(): AutoGeneratedClassDef {
    if (!this.extractedData) throw Error("unconsistent data");
    const { functions, name } = this.extractedData;
    const classNamme = `AutoGenerated${name}`;
    const makeFnMember = (fnInfo: FunctionInfo) => {
      const prms = fnInfo.parameters.map((p) => p.name).join(",");
      const fnName = fnInfo.name;
      const depName = `${classNamme}.${fnName}`;
      const fnBody = `${
        fnInfo.returnType === "void" ? "" : "return"
      } this.IoC.resolve("${depName}")(this.obj,${prms});`;
      return `${fnName}(${prms}){${fnBody}}`;
    };
    const ctor = `constructor(readonly obj:unknown, readonly IoC:any){}`;
    const code = `class ${classNamme}{
      ${ctor}
      ${functions.map(makeFnMember).join("")}
    }`;

    return {
      bootstrapFn: new Function(`${tsCompile(code)} return ${classNamme};`),
      name: classNamme,
    };
  }
}
